const axios = require('axios');

const GROQ_ENDPOINT = 'https://api.groq.com/openai/v1/chat/completions';
const MODEL = 'meta-llama/llama-4-scout-17b-16e-instruct';

const PROMPT_SYSTEM = `You are an expert code reviewer. Your task is to analyze the provided code and provide a detailed, structured review that highlights both strengths and areas for improvement. 

IMPORTANT: Your response MUST be properly formatted in Markdown. Use proper line breaks, headers, lists, and code blocks to ensure readability.`;

const PROMPT_USER = `# Code Review Request

Please review the following code and provide a detailed analysis. Structure your response using the sections below. Be sure to use proper Markdown formatting, including line breaks between paragraphs and list items.

## ðŸ“‹ Overview
[Provide a brief summary of the code's purpose and overall quality.]

## ðŸ—ï¸ Code Structure
- File organization
- Module/Component breakdown
- Dependencies

## ðŸ§© Readability & Style
- Code formatting and consistency
- Naming conventions
- Comments and documentation

## ðŸ› Potential Issues
- Bugs and edge cases
- Performance concerns
- Security vulnerabilities

## ðŸ› ï¸ Improvement Suggestions
- Code organization
- Best practices
- Potential refactoring opportunities

## ðŸš€ Quick Wins
- Easy fixes that can be implemented immediately
- Low-hanging fruit for improvement

## ðŸ”„ Before & After Example (if applicable)
\`\`\`javascript
// Before
function example() { return {a:1,b:2}; }

// After
function example() { 
  return { 
    a: 1,
    b: 2 
  }; 
}
\`\`\`

## ðŸ“ Final Thoughts
[Overall assessment and next steps]

---

Code to review:
`;

async function reviewCode(codeContent) {
  console.log('\nðŸ“¤ Sending request to Groq API...');
  console.log(`ðŸ“ Code content length: ${codeContent.length} characters`);
  
  try {
    const body = {
      model: MODEL,
      messages: [
        { role: 'system', content: PROMPT_SYSTEM },
        { role: 'user', content: `${PROMPT_USER}\n\n${codeContent}` }
      ],
      max_tokens: 1500,
      temperature: 0.7
    };

    console.log('ðŸ”„ Making API request to Groq...');
    const startTime = Date.now();
    
    const res = await axios.post(GROQ_ENDPOINT, body, {
      headers: {
        Authorization: `Bearer ${process.env.GROQ_API_KEY}`,
        'Content-Type': 'application/json'
      },
      timeout: 30000 // 30 seconds timeout
    });
    
    const responseTime = Date.now() - startTime;
    
    if (!res.data.choices || !res.data.choices[0]?.message?.content) {
      console.error('âŒ Unexpected API response format:', JSON.stringify(res.data, null, 2));
      throw new Error('Invalid response format from Groq API');
    }
    
    let responseContent = res.data.choices[0].message.content;
    const usage = res.data.usage || {};
    
    // Clean up and format the response
    responseContent = responseContent
      // Ensure consistent line endings
      .replace(/\r\n/g, '\n')
      // Ensure double newlines between sections
      .replace(/\n(## )/g, '\n\n$1')
      // Ensure list items have proper spacing
      .replace(/\n- /g, '\n\n- ')
      // Remove any potential duplicate code block markers
      .replace(/```(?:markdown)?\n```/g, '')
      .trim();
    
    // Ensure the response starts with a main header
    if (!responseContent.startsWith('#')) {
      responseContent = `# Code Review\n\n${responseContent}`;
    }
    
    // Add timestamp and metadata
    const timestamp = new Date().toISOString();
    const metadata = `\n\n---\n\n*Generated by ${res.data.model} on ${new Date().toLocaleString()}*  
*Tokens used: ${usage.total_tokens || 'N/A'}*`;
    
    responseContent = responseContent + metadata;
    
    console.log('âœ… Received response from Groq API');
    console.log(`â±ï¸  Response time: ${responseTime}ms`);
    console.log(`ðŸ“Š Tokens used: ${usage.total_tokens || 'N/A'}`);
    console.log(`ðŸ“„ Response length: ${responseContent.length} characters`);
    console.log('--- Response Preview ---');
    console.log(responseContent.substring(0, 200) + (responseContent.length > 200 ? '...' : ''));
    console.log('-------------------------');
    
    // Convert markdown to HTML for better frontend display
    const htmlContent = markdownToHtml(responseContent);
    
    return { 
      content: responseContent,  // Keep original markdown
      html: htmlContent,         // Add HTML version
      metadata: {
        model: res.data.model,
        id: res.data.id,
        timestamp,
        usage: {
          prompt_tokens: usage.prompt_tokens,
          completion_tokens: usage.completion_tokens,
          total_tokens: usage.total_tokens
        },
        response_time_ms: responseTime
      }
    };
    
  } catch (error) {
    console.error('âŒ Error in Groq API request:');
    
    if (error.response) {
      // The request was made and the server responded with a status code
      // that falls out of the range of 2xx
      console.error('Status:', error.response.status);
      console.error('Data:', error.response.data);
      console.error('Headers:', error.response.headers);
    } else if (error.request) {
      // The request was made but no response was received
      console.error('No response received from Groq API');
      console.error('Request:', error.request);
    } else {
      // Something happened in setting up the request that triggered an Error
      console.error('Error:', error.message);
    }
    
    console.error('Error config:', error.config);
    throw error;
  }
}

/**
 * Parses the raw response text into structured sections for frontend display
 * @param {string} text - The raw response text
 * @returns {Array} - Array of section objects with title and content
 */
function parseResponseIntoSections(text) {
  // First, normalize line endings and clean up the text
  let content = text
    .replace(/\r\n/g, '\n')
    .replace(/\n{3,}/g, '\n\n')  // Replace 3+ newlines with 2
    .trim();

  // Split by markdown headers (##)
  const sections = [];
  const headerRegex = /^(#{1,6})\s*(.*?)(?:\s*#*)?\s*$/gm;
  let lastIndex = 0;
  let match;
  let currentSection = { title: 'Overview', content: [] };

  // Process each header
  while ((match = headerRegex.exec(content)) !== null) {
    const [fullMatch, hashes, title] = match;
    const level = hashes.length;
    
    // If this isn't the first match, save the previous section
    if (match.index > lastIndex) {
      const sectionContent = content
        .substring(lastIndex, match.index)
        .trim();
      
      if (sectionContent) {
        if (currentSection.content.length > 0) {
          currentSection.content = currentSection.content.join('\n').trim();
          sections.push({ ...currentSection });
        }
        currentSection = {
          title: title.trim(),
          content: [sectionContent]
        };
      }
    }
    
    lastIndex = match.index + fullMatch.length;
  }

  // Add the last section
  if (lastIndex < content.length) {
    const sectionContent = content.substring(lastIndex).trim();
    if (sectionContent) {
      if (currentSection.content.length > 0) {
        currentSection.content.push(sectionContent);
        currentSection.content = currentSection.content.join('\n').trim();
      } else {
        currentSection.content = sectionContent;
      }
      sections.push(currentSection);
    }
  } else if (currentSection.content.length > 0) {
    currentSection.content = currentSection.content.join('\n').trim();
    sections.push(currentSection);
  }

  // Process each section's content
  return sections.map(section => ({
    ...section,
    content: formatSectionContent(section.content)
  }));
}

/**
 * Formats section content for better display
 * @param {string} content - The raw section content
 * @returns {string} Formatted content
 */
function formatSectionContent(content) {
  if (!content) return '';
  
  // Ensure proper spacing around lists
  let formatted = content
    .replace(/([^\n])\n- /g, '$1\n\n- ')  // Add newline before list items
    .replace(/\n- ([^\n]+)/g, '\n- $1')  // Ensure space after -
    .replace(/([^\n])\n\s*\n-/g, '$1\n\n-')  // Fix double newlines before lists
    .replace(/\n{3,}/g, '\n\n');  // Limit consecutive newlines

  // Ensure code blocks have proper spacing
  formatted = formatted.replace(/```(\w*)\n([\s\S]*?)\n```/g, '\n```$1\n$2\n```\n');

  return formatted.trim();
}

/**
 * Converts markdown to HTML with proper formatting for code reviews
 * @param {string} markdown - The markdown text to convert
 * @returns {string} HTML string
 */
function markdownToHtml(markdown) {
  if (!markdown) return '';

  // Process code blocks first to preserve them
  let html = markdown
    // Convert code blocks with language
    .replace(/```(\w*)\n([\s\S]*?)\n```/g, (match, lang, code) => {
      return `<pre><code class="language-${lang || 'text'}">${escapeHtml(code)}</code></pre>`;
    })
    // Convert inline code
    .replace(/`([^`]+)`/g, '<code>$1</code>')
    // Headers
    .replace(/^### (.*$)/gm, '<h3>$1</h3>')
    .replace(/^## (.*$)/gm, '<h2>$1</h2>')
    .replace(/^# (.*$)/gm, '<h1>$1</h1>')
    // Lists
    .replace(/^\s*[-*+] (.+$)/gm, '<li>$1</li>')
    .replace(/(<li>.*<\/li>)/gs, (match) => {
      // Wrap consecutive list items in <ul>
      if (match.includes('</li>')) {
        return `<ul>${match}</ul>`;
      }
      return match;
    })
    // Bold and italic
    .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
    .replace(/\*([^*]+)\*/g, '<em>$1</em>')
    .replace(/__([^_]+)__/g, '<strong>$1</strong>')
    .replace(/_([^_]+)_/g, '<em>$1</em>')
    // Links
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>')
    // Images
    .replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="max-width:100%;">')
    // Line breaks and paragraphs
    .replace(/\n\n/g, '</p><p>')
    .replace(/\n/g, '<br>');

  // Ensure proper HTML structure
  if (!html.startsWith('<')) {
    html = `<p>${html}`;
  }
  if (!html.endsWith('>')) {
    html = `${html}</p>`;
  }

  // Add some basic styling
  return `
    <div class="code-review" style="
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      color: #24292e;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    ">
      ${html}
      <style>
        pre {
          background: #f6f8fa;
          padding: 16px;
          border-radius: 6px;
          overflow-x: auto;
          margin: 16px 0;
        }
        code {
          font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
          font-size: 14px;
          line-height: 1.45;
        }
        h1 { font-size: 2em; margin: 0.67em 0; }
        h2 { font-size: 1.5em; margin: 0.83em 0; }
        h3 { font-size: 1.17em; margin: 1em 0; }
        ul, ol { padding-left: 2em; margin: 1em 0; }
        li { margin: 0.25em 0; }
        a { color: #0366d6; text-decoration: none; }
        a:hover { text-decoration: underline; }
      </style>
    </div>`;
}

/**
 * Escapes HTML special characters
 */
function escapeHtml(unsafe) {
  return unsafe
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

module.exports = { reviewCode };
